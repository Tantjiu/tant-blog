# 二、访问远程服务

## 2.1 远程服务调用(RPC)

- 远程服务调用解决了哪些问题？如何解决的？

### 2.1.1 进程间通信

- 最初设计RPC就是希望能让计算机能够像调用本地方法一样，调用远程方法

### 2.1.2 通信的成本

网络分布式运算的八宗罪，以下这八句反话也是程序员在网络编程中经常忽略的八大问题

- 网络是可靠的
- 延迟是不存在的
- 带宽是无限的
- 网络是安全的
- 拓扑结构是一成不变的
- 总会有一个管理员
- 不必考虑传输成本
- 网络都是同质化的

### 2.1.3 三个基本问题

- 如何表示数据
  - 序列化与反序列化

- 如何传递数据
  - 传递数据不仅仅是两个服务扔一个序列化数据流就完事了，还有其他许多信息，比如：异常、超时、安全、认证、授权、事务等

- 如何表示方法
  - 对于同一语言，通常不是什么问题，但对于不同语言，事情就麻烦起来了，需要有一个统一的跨语言标准


## 2.2 REST设计风格

- rest与rpc思想上的核心差异是抽象的目标不一样，一个是面向过程、另一个是面向资源

- 应满足的六大风格
  - 客户端与服务端分离
  - 无状态
    - 每次从客户端发出来的请求，应包含所有必要的上下文信息，会话信息应由客户端进行保存、维护
    - 但实际上大型应用中，服务端无状态很难做到，因为大型系统的上下文信息能膨胀到客户端无法接受的地步，而在服务端的内存、回话、数据库或缓存等地方持有一定状态成了主流的方案
  - 可缓存
  - 分层系统
  - 统一接口
  - 按需代码

# 三、事务处理

## 3.1 本地事务

- 事务的实现原理绕不开 ARIES理论，这部分可课外了解一下
- 数据库通过日志实现事务的原子性和持久性是当今的主流方案

## 3.2 全局事务

- XA事务处理框架

  - 准备阶段：这一阶段协调者会询问所有参与者是否准备好了提交，这个时候参与者与实际提交的区别是还持有数据锁
  - 提交阶段：所有参与者均准备好了之后，协调者会先提交自身事务，再告诉所有参与者提交事务，否则则所有参与者回滚事务

  这两个过程称之为：两阶段提交(2 Phase Commit)，他能保证一致性还需要一些其他的条件

  - 假设网络在短时间内是可靠的，即提交阶段不会丢失消息，网络通讯全程不出差错
  - 假设因网络分区，机器崩溃或者其他原因导致的失联节点最终能够恢复吗，不会永久性的出于失联状态，这样失联机器一恢复，就能从日志中找到已准备妥当但尚未提交的事务数据

  请注意，上面所说的协调者和参与者，一般都是有数据库自己扮演

  几个显著的缺点：

  - 单点问题：协调者如果出了问题，参与者只能一直等待提交或者回滚指令，不能有超时机制和超时处理
  - 性能问题：整个两阶段提交的过程中，所有参与者被绑定成统一的整体，需要经过两次远程服务调用，三次数据持久化（准备阶段、协调者做状态持久化、提交阶段日志写入）
  - 一致性风险：当前提条件不成立

## 3.3 共享事务

多个服务共享一个数据源，可作为了解，实际上可能是个伪需求

数据源与数据库的区别：

- 数据源：提供数据的逻辑设备，可以由多个数据库提供支持

## 3.4 分布式事务

### 3.4.1 CAP理论

- 一致性(Consistency)：数据在任何时刻、任何分布式节点中所看到的都是符合预期的
- 可用性(Availability)：系统不间断的提供服务的能力
- 分区容忍性(Partition Tolerance)：代表分布式环境中部分节点因网络原因而彼此失联后，系统仍能正常提供服务的能力

大部分时候，AP都是主流的选择

### 3.4.2 可靠事件队列

- 不断重试来保证可靠性的解决方案

### 3.4.3 TCC事务

- Try-Confirm-Cancel
- Try阶段：完成所有业务可执行性的检查，并预留好全部需要用到的业务资源
- Confirm阶段：确认执行阶段、直接使用Try阶段准备的资源来完成业务处理，可能会重复执行，因此需要幂等
- Cancel阶段：释放Try阶段所预留的业务资源，可能会重复执行，因此需要幂等

业务侵入性强，开发成本高，但具有较强的隔离性，性能较强

### 3.4.4 SAGA事务

- 将大事务拆解成很多个小事务
- 为每一个小事务设计补偿动作、所有事务均正常提交，则事务完成，否则则
  - 正向恢复：一直对失败的事务进行重试、一直到成功为止
  - 反向恢复：如果事务失败、执行其补偿机制、直至成功，要求补偿机制一定要执行成功
- 基于数据补偿来代替回滚的模式
